# 小说标注工具 - 开发文档

## 1. 技术栈与架构

*   **前端框架**: React 19 (using function components and hooks)
*   **语言**: TypeScript
*   **样式**: Emotion (`@emotion/styled`) for component-level styling, with a centralized style system in `styles.ts`.
*   **构建工具**: Vite
*   **架构**:
    *   **单页面应用 (SPA)**: The application runs entirely on the client-side after initial load.
    *   **组件化**: The UI is broken down into reusable React components located in the `components/` directory.
    *   **状态管理**: A centralized state management approach is used, where the main state (novels, tags, annotations) resides in the root `App` component and is passed down to child components via props. State updates are handled by callback functions.
    *   **路由**: A simple hash-based routing system (`window.location.hash`) is implemented in the `App` component to navigate between pages (Login, Projects, Editor, etc.).

## 2. 项目文件结构

```
/
├── components/         # React components, organized by feature
│   ├── auth/           # Login, Registration pages
│   ├── editor/         # The main editor page and its hooks
│   ├── projects/       # The novel projects landing page
│   └── ...             # Shared components like TagPanel, ContentPanel
├── data/               # Static data for bootstrapping, e.g., demo content
├── doc/                # Documentation files
│   ├── 需求文档.md     # Product Requirements Document (PRD)
│   └── 开发文档.md     # This development document
├── index.tsx           # Main application entry point, root component
├── styles.ts           # Shared style constants (colors, spacing, fonts)
├── types.ts            # Global TypeScript type definitions
├── utils.ts            # Utility functions (ID generation, text processing)
└── vite.config.ts      # Vite build configuration
```

## 3. 核心逻辑与数据流

### 3.1 数据模型 (`types.ts`)

*   **`User`**: Represents the logged-in user.
*   **`Novel`**: The core data for a novel, including its text, chapters, and now also `storylines` and `plotAnchors`.
*   **`Chapter`**: A segment of a novel with content and original position.
*   **`Tag`**: A user-defined, hierarchical tag. Global to a user.
*   **`Annotation`**: A link between a text **range** (`startIndex`, `endIndex`) in a `Novel` and one or more `Tag`s.
*   **`Storyline` (新增)**: A new interface representing a macro plotline with an id, name, and color.
*   **`PlotAnchor` (新增)**: A new interface representing a marker at a specific text **position** (`position`), linked to one or more `Storyline` IDs.

### 3.2 状态管理 (`index.tsx`)

The `App` component remains the "single source of truth" for all primary data arrays (`novels`, `allUserTags`, `allUserAnnotations`). Handler functions for creating, updating, and deleting this data are defined here and passed down.

### 3.3 编辑器核心架构：统一分析视图

为了实现需求文档中描述的统一、流畅的交互体验，同时避免创建一个难以维护的“巨无霸”组件，编辑器将采用**模块化和关注点分离 (Separation of Concerns)** 的架构。

#### 3.3.1 基础交互编辑器 (`BaseInteractiveEditor`) 组件

这是统一分析视图的核心。它是一个“哑”组件，其职责非常单一：

1.  **高效渲染**: 负责将小说文本渲染成一段段的段落。
2.  **内联编辑**: 实现核心的“双击段落进行内联编辑”功能，并向上触发文本变更事件。
3.  **渲染图层**: 接收 `highlights`（高亮范围数组）和 `anchors`（锚点位置数组）作为 props，并将它们准确地渲染在文本流的正确位置。它**不关心**这些图层代表什么（是标签还是剧情线），只负责绘制。
4.  **暴露事件**: 对外暴露一系列交互钩子或事件，例如 `onTextSelect` (当用户划选文本时触发), `onParagraphHover` (当鼠标在段落间悬停时触发)。

#### 3.3.2 可插拔的系统钩子 (Pluggable System Hooks)

各个具体业务功能（标注、剧情线）将作为独立的自定义 Hooks 实现，它们“插入”到基础编辑器提供的交互事件上。

1.  **`useAnnotationSystem` Hook**:
    *   **职责**: 封装所有与“标签”和“标注”相关的状态和逻辑。
    *   **工作方式**:
        *   它“监听”`BaseInteractiveEditor` 的 `onTextSelect` 事件。
        *   当事件触发时，它负责渲染自己的UI（如上下文菜单）。
        *   当用户创建或修改标注后，它更新全局的 `annotations` 状态，并计算出 `highlights` 数组，将其传递给 `BaseInteractiveEditor` 进行渲染。

2.  **`useStorylineSystem` Hook**:
    *   **职责**: 封装所有与“故事线”和“剧情锚点”相关的状态和逻辑。
    *   **工作方式**:
        *   它“监听”`BaseInteractiveEditor` 的 `onParagraphHover` 事件。
        *   当事件触发时，它负责渲染自己的UI（如悬浮的 `+` 按钮）。
        *   当用户创建锚点后，它更新 `novel` 对象中的 `plotAnchors` 状态，并计算出 `anchors` 数组，将其传递给 `BaseInteractiveEditor` 进行渲染。

#### 3.3.3 模式切换的实现

`NovelEditorPage` 组件将根据当前的 `editorMode`（'writing', 'annotation', 'storyline'）状态，来决定：

1.  **加载哪个系统钩子**：例如，在“标注模式”下，激活 `useAnnotationSystem`；在“剧情线模式”下，激活 `useStorylineSystem`。
2.  **渲染哪个侧边栏**：根据模式显示对应的“标签管理”或“故事线管理”面板。
3.  **传递哪个图层数据**：将当前激活的系统钩子产出的图层数据（`highlights` 或 `anchors`）传递给 `BaseInteractiveEditor`。

通过这种方式，我们在用户层面实现了无缝的统一体验，同时在代码层面保持了各个功能模块的**高内聚、低耦合**，极大地降低了开发和维护的复杂性。

## 4. 开发注意事项

### 4.1 换行符标准化 (重要)

**所有接收和处理用户输入的文本，必须立即将其换行符标准化为 `\n`。** 这是确保标注、锚点等元数据位置索引准确无误的基石。

**代码示例**:
```typescript
const normalizedText = text.replace(/\r\n|\r/g, '\n');
```

在未来添加任何涉及文本处理的功能时，请务必首先进行此标准化步骤。

### 4.2 数据不可变性

当更新状态（尤其是数组和对象）时，始终创建新的实例而不是直接修改（mutate）旧的实例。

*   **正确**: `setItems(prevItems => [...prevItems, newItem]);`
*   **错误**: `const items = currentItems; items.push(newItem); setItems(items);`

### 4.3 样式一致性

尽量使用 `styles.ts` 中定义的共享样式常量（`COLORS`, `SPACING`, `FONTS` 等）来编写样式，以保持整个应用视觉风格的统一。

### 4.4 类型安全

所有核心数据模型都已在 `types.ts` 中定义。请在所有组件和函数中为 props、 state 和变量添加明确的类型，以充分利用TypeScript的静态检查优势。